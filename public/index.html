<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Boss Attendance - Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div id="app">
    <header class="header">
      <h1>Boss Attendance — Live</h1>
      <div class="small">Realtime • Discord voice detection • OCR image upload</div>
    </header>

    <main class="grid">
      <!-- Left column: Spawning Boss -->
      <section class="panel left">
        <h2>Spawning Boss</h2>
        <div class="form">
          <input id="bossName" placeholder="boss name" />
          <input id="bossDate" type="datetime-local" />
          <div class="row">
            <button id="addBoss">Add Boss</button>
            <button id="clearFields">Clear</button>
          </div>
        </div>

        <div class="boss-list" id="bossList"></div>
      </section>

      <!-- Center: Active / Attendance -->
      <section class="panel center">
        <h2>Active Boss / Attendance</h2>
        <div class="active-card" id="activeCard">
          <div class="active-info">
            <div><strong>Active:</strong> <span id="activeName">—</span></div>
            <div><strong>Spawn:</strong> <span id="activeSpawn">—</span></div>
            <div><strong>Remaining:</strong> <span id="activeRemaining">—</span></div>
            <div class="row">
              <button id="setActive">Set Active</button>
              <button id="updateDiscord">Update to Discord</button>
            </div>
          </div>
        </div>

        <h3>Discord Voice — Live</h3>
        <div id="voiceList" class="list"></div>

        <h3>Attendance (matches)</h3>
        <div id="attendanceList" class="list"></div>
      </section>

      <!-- Right: Upload & OCR -->
      <section class="panel right">
        <h2>Image Upload / OCR</h2>
        <input id="imageInput" type="file" accept="image/*" />
        <div class="row">
          <button id="uploadBtn">Upload & Detect</button>
        </div>

        <h3>Uploads</h3>
        <div id="uploadList" class="list"></div>
      </section>
    </main>

    <footer class="footer">
      <small>Set environment variables for Discord token & webhook on the server. Realtime via Socket.IO.</small>
    </footer>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // client-side JS (inlined for simplicity)
    const socket = io();

    let state = { data: null, voice: [] };

    function q(id){ return document.getElementById(id); }

    function formatTimeRemaining(spawnISO){
      if(!spawnISO) return '—';
      const spawn = new Date(spawnISO);
      const now = new Date();
      const diff = Math.max(0, Math.floor((spawn - now)/1000));
      const h = Math.floor(diff/3600); const m = Math.floor((diff%3600)/60); const s = diff%60;
      return (h? h+'h ':'') + (m? m+'m ':'') + s+'s';
    }

    function renderBosses(bosses){
      const el = q('bossList'); el.innerHTML = '';
      bosses.forEach(b=>{
        const div = document.createElement('div');
        div.className = 'boss-row';
        div.innerHTML = `<div class="boss-left"><strong>${b.name}</strong><div class="muted">${new Date(b.spawnDateISO).toLocaleString()}</div></div>
                        <div class="boss-right">
                          <button data-id="${b.id}" class="setActiveBtn">Set Active</button>
                          <button data-id="${b.id}" class="delBtn">Delete</button>
                        </div>`;
        el.appendChild(div);
      });

      document.querySelectorAll('.setActiveBtn').forEach(btn=> btn.onclick = e => {
        const id = btn.dataset.id;
        const boss = state.data.bosses.find(x=>x.id===id);
        socket.emit('set_active', boss);
      });
      document.querySelectorAll('.delBtn').forEach(btn=> btn.onclick = e => {
        const id = btn.dataset.id;
        fetch('/api/bosses/' + id, { method: 'DELETE' }).then(()=>{/* handled by socket update */});
      });
    }

    function renderActive(active){
      q('activeName').textContent = active?.name ?? '—';
      q('activeSpawn').textContent = active?.spawnDateISO ? new Date(active.spawnDateISO).toLocaleString() : '—';
      q('activeRemaining').textContent = active?.spawnDateISO ? formatTimeRemaining(active.spawnDateISO) : '—';
    }

    function renderVoiceList(voiceArr){
      const el = q('voiceList'); el.innerHTML = '';
      voiceArr.forEach(v => {
        const joinedSec = Math.floor((Date.now() - v.joinedAt)/1000);
        const hr = Math.floor(joinedSec/3600), min = Math.floor((joinedSec%3600)/60), sec = joinedSec%60;
        const dur = (hr? hr+'h ':'') + (min? min+'m ':'') + sec+'s';
        const div = document.createElement('div');
        div.className = 'voice-row';
        div.dataset.userid = v.id;
        div.innerHTML = `<div><strong>${v.displayName || v.username}</strong><div class="muted">in voice • ${dur}</div></div>`;
        el.appendChild(div);
      });
    }

    function renderUploads(records){
      const el = q('uploadList'); el.innerHTML = '';
      (records || []).slice(0,10).forEach(r => {
        const div = document.createElement('div');
        div.className = 'upload-row';
        let detected = r.detected && r.detected.length ? r.detected.join(', ') : 'No text detected';
        div.innerHTML = `<div><strong>${new Date(r.uploadedAt).toLocaleString()}</strong><div class="muted">${detected}</div></div>
                         <div class="upload-right"><a href="/uploads/${r.file}" target="_blank">preview</a></div>`;
        el.appendChild(div);
      });
    }

    function buildAttendanceList(voice, uploads){
      // Match OCR names with voice members by simple case-insensitive substring/prefix
      const uploadNames = (uploads && uploads.length) ? uploads[0].detected : [];
      const attendanceEl = q('attendanceList'); attendanceEl.innerHTML = '';
      voice.forEach(v => {
        const username = v.displayName || v.username;
        // compute duration in sec
        const durationSec = Math.floor((Date.now() - v.joinedAt)/1000);
        // find matches
        const matched = uploadNames.filter(n => {
          if(!n) return false;
          // normalize
          const a = n.toLowerCase().replace(/\s+/g,'');
          const b = username.toLowerCase().replace(/\s+/g,'');
          return b.includes(a) || a.includes(b) || b.startsWith(a) || a.startsWith(b);
        });
        const div = document.createElement('div');
        div.className = 'att-row';
        div.innerHTML = `<div><strong>${username}</strong><div class="muted">duration: ${Math.floor(durationSec/60)}m ${durationSec%60}s ${matched.length? ' • matched: '+matched.join(', '):''}</div></div>`;
        attendanceEl.appendChild(div);
      });
    }

    // initial DOM binding
    q('addBoss').onclick = ()=>{
      const name = q('bossName').value.trim();
      const spawnDateISO = q('bossDate').value ? new Date(q('bossDate').value).toISOString() : null;
      if(!name || !spawnDateISO) return alert('Enter boss name and spawn datetime');
      fetch('/api/bosses', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name, spawnDateISO })});
      q('bossName').value = ''; q('bossDate').value = '';
    };
    q('clearFields').onclick = ()=>{ q('bossName').value=''; q('bossDate').value=''; };

    q('setActive').onclick = ()=>{
      const first = state.data?.bosses?.[0];
      if(!first) return alert('No boss to set active');
      socket.emit('set_active', first);
    };

    q('updateDiscord').onclick = ()=>{
      const active = state.data.activeBoss;
      if(!active) return alert('No active boss to update');
      const attendance = state.voice.map(v => {
        return { username: v.displayName || v.username, durationSec: Math.floor((Date.now()-v.joinedAt)/1000), matchedNames: [] };
      });
      // find matched names from last upload
      const uploads = state.data.attendanceRecords || [];
      const last = uploads[0];
      if (last) {
        attendance.forEach(a => {
          a.matchedNames = last.detected.filter(n=>{
            const aNorm = (a.username||'').toLowerCase().replace(/\s+/g,'');
            const nNorm = (n||'').toLowerCase().replace(/\s+/g,'');
            return aNorm.includes(nNorm) || nNorm.includes(aNorm) || aNorm.startsWith(nNorm) || nNorm.startsWith(aNorm);
          });
        });
      }
      socket.emit('update_to_discord', { activeBoss: active, attendance });
    };

    q('uploadBtn').onclick = async ()=>{
      const f = q('imageInput').files[0];
      if(!f) return alert('Choose an image first');
      const fd = new FormData(); fd.append('image', f);
      q('uploadBtn').disabled = true;
      const r = await fetch('/api/upload', { method:'POST', body: fd });
      const j = await r.json();
      q('uploadBtn').disabled = false;
      if (j.ok) {
        alert('Upload OK — detected: ' + (j.detected.join(', ') || 'none'));
      } else alert('Upload failed: ' + j.err);
    };

    // socket events
    socket.on('init', payload => {
      state.data = payload.data;
      state.voice = payload.voice.map(v=> ({...v}) );
      renderAll();
    });

    socket.on('data_update', d => {
      state.data = d;
      renderAll();
    });

    socket.on('voice_update', voice => {
      // voice items may not contain joinedAt (if from server it does)
      state.voice = voice.map(v => ({ ...v }));
      renderAll();
    });

    socket.on('upload_done', rec => {
      // push rec to data on client side
      state.data.attendanceRecords = state.data.attendanceRecords || [];
      state.data.attendanceRecords.unshift(rec);
      renderAll();
    });

    socket.on('discord_ok', msg => { alert('Discord: ' + msg); });
    socket.on('discord_error', msg => { alert('Discord error: ' + msg); });

    function renderAll(){
      if(!state.data) return;
      renderBosses(state.data.bosses || []);
      renderActive(state.data.activeBoss);
      renderVoiceList(state.voice || []);
      renderUploads(state.data.attendanceRecords || []);
      buildAttendanceList(state.voice || [], state.data.attendanceRecords || []);
    }

    // update remaining every second
    setInterval(()=>{
      if(state.data && state.data.activeBoss) renderActive(state.data.activeBoss);
      // also request small heartbeat for voice durations (not strictly necessary)
    }, 1000);
  </script>
</body>
</html>
